# Design-Pattern-For-Swift
23种设计模式：  1.简单工厂模式 2.工厂方法模式  区别就是： 简单工厂需要传入后通过if判断需要调用哪个操作 （不透明） 工厂方法就是一开始就直接定义我需要调用哪个子类（半透明）  3.策略  用一个维护类来集成所有实现协议的类来调用。  4.代理 在界面上有个代理类与真实类实现同一个协议，且代理类里面有真实类的引用，这样只需要调用代理类就可以。  5.装饰 在原有的对象上面扩展装饰不同的方法（东西）  6.模板方法模式 子类继续基类  7.外观模式 统一一个入口实现不同类的方法  8.建造者模式 一个管理器 管理各个模块的建设出不同的东西  9.观察者模式 在注册类中有一个集合，把所有监听加入这个集合，当注册类通知时遍历整个集合执行统一的方法实现  10.抽象工厂模式 在工厂上面再抽象一层由不同工厂造出不同的产品，而产品也抽象出来种类，这样就可以不同工厂 造 不同种类  11.状态模式 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类  12.适配器模式 希望复用一些现存的类，但是接口又与复用环境要求不一致的情况  13.备忘录模式 不破坏对象内部状态，在之外保存记录，在适当的时候可以回复记录值  14.组合模式 子节点不会下一级，组合就是部分-整体 让用户的对象具有一致性  15.迭代器模式 提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示 iOS的Block迭代、数组迭代都是迭代器模式的典型实现。  16.单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点  17.桥接模式 抽象和实现分离，就像手机和软件分离一样，手机有品牌，软件有app类型  18.命令模式 将请求封装到一个对象内，可以排队或者请求日志，可以执行命令操作  19.职责链模式 在类中增加一个上级类和一个请求，如果自己处理不了，就交给上级去处理 iOS事件的传递和响应就是职责链模式的实现。  20.中介者模式 根据迪米特原则，两个不相关的对象不应该直接通讯。 所以中间处理者来调解各个对象之间的交互，使各个对象耦合松散  21.享元模式 共享初始化过的对象，在日常当中初始化过一次物品这个不需要更新，直接拿过来用，共享这个实例节省开销 比如iOS的RunTime就是享元的一个事件。每个对象调用的方法其实是他对应的类里面实现的。比如NSObject定义了很多方法让所有对象都可以使用。类对象永远只有一个，而对应的实例对象有无数个。  22.解释器模式 一段语言通过不同解释器进行统一形成听的懂语言  23.访问者模式 很多个不可变的对象，每个人接触时有不一样的感受。 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类(男人，女人)的前提下定义作用于这些元素的新操作(喜怒哀乐)。他把数据结构(男人，女人)和作用于数据结构之上的操作(喜怒哀乐)之间的耦合解脱开，使得操作集合可以相对自由地演化  24.原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。    单一职责原则（SRP），就一个类而言，只做一件事。 开放-封闭原则（OCP），是说软件实体（类、模块、函数等等）应该可以拓展，但是不可修改。 依赖倒转原则（DIP），A. 高层模块不应该依赖低层模块，两个都应该依赖抽象。B. 抽象不应该依赖细节，细节应该依赖抽象。 里氏代换原则（LSP），子类型必须能够替换掉它们的父类型。 迪米特法则（LoD），如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 合成/聚合复用原则（CARP），尽量使用合成/聚合，尽量不要使用类继承。
